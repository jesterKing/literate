<html>
  <head>
    <link rel="stylesheet" type="text/css" href="./style.css">
  </head>
  <body>
  <h1>Literate Programming</h1>
<p><strong>Literate programming</strong> is a programming paradigm introduced by Donald Knuth. A
program is written in a natural language with snippets of code interspersed.
From this text usable source code is generated, along with well formatted
human-readable document.</p>
<p>The most important influence for this <strong>literate programming</strong> extension is the
<a href="https://pbr-book.org">PBR Book</a>.</p>
<p>This extension provides a set of tools that help the programmer writing literate
programs. Through automation the process of writing literate programs should be
as painless as possible. The programming writes his literate programs using
Markdown. When a literate programmer needs a snippet they can add a code fence.
In this extension snippets are called code fragments.</p>
<p>The approach for this extension is based on Markdown documents, as noted
earlier. The Markdown specification is only slightly adapted to make supporting
<strong>literate programming</strong> easy. The code fragments are expressed in code fences
as per the Markdown specification, either with surrounding tripple backticks or
tripple tildes. Along with the programming language identifier the opening line
has been extended to contain the fragment name and type as essentially options
to the code fence. This opening line thus will look like
<code>py : &lt;&lt;fragment name&gt;&gt;</code> to create a new fragment, or like
<code>py : &lt;&lt;fragment name&gt;&gt;=+</code> to amend an existing fragment.</p>
<p>To create actual source files a fragment creation line needs to be used with a
slightly extended form of the creation tag mentioned above. The name has to be
postixed with the string <code>.*</code> betueen the chevrons. Furthermore a file
name needs to be specied after the equal sign. This is essentially a relative
path that is going to be appended each workspace folder as the root. A top level
fragment looks like <code>py : &lt;&lt;top-level fragment.*&gt;&gt; ./src/source.py</code>. The
name of this fragment is <code>top-level fragment</code>, and once it has been fully
extrapolated will be written to a file in the workspace folder under <code>src</code> as
the file <code>source.py</code>.</p>
<p>The <strong>Literate Programming</strong> extension allows the program author to write
multiple projects in the same Visual Studio Code workspace. Each workspace
folder is the root for its own literate project. Within each project there can
be one or more <strong>literate</strong> files. These files have the extension <code>.literate</code>.
One literate file can contain zero or more code fragments. A literate file can
also contain more than one top level fragment. In other words an author can
create multiple source files within just one <strong>literate</strong> document.</p>
<p>This text describes the <strong>Literate Programming</strong> extension as a <strong>literate</strong>
program.</p>
<h2>Fragment Model</h2>
<p>The tools provided by the <strong>Literate Programming</strong> extension are built around
one repository of the project providing all necessary information around
fragments.</p>
<p>The fragment repository handles parsing of <strong>literate</strong> documents, reacting to
changes made by users. The repository provides all fragments found in the
projects added to the current workspace. Additionally the repository will write
out source files and rendered HTML files.</p>
<p>The fragment model is defined in the <code>FragmentRepository</code> class, which will be
described in detail after introducing a couple of classes that help the
repository.</p>
<h3>FragmentMap class</h3>
<p>The <code>FragmentMap</code> class holds a map of strings, the fragment names, and their
associated <code>FragmentInformation</code>. This map is available through the <code>map</code>
property. The class provides also a <code>clear</code> method and a <code>dispose</code> method.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment map&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentMap</span> {
  map : <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
  {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;();
  }

  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>)
  {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">clear</span>();
  }

  <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>)
  {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">clear</span>();
  }
};
</code></pre>

</div>
</div><h3>List of GrabbedState</h3>
<p>The class <code>GrabbedStateList</code> holds an array of <code>GrabbedState</code> accessible through
the <code>list</code> property. The class provides <code>clear</code> and <code>dispose</code> properties.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;list of grabbed states&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrabbedStateList</span> {
  list : <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
  {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
  }

  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>)
  {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
  }

  <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>)
  {
    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)
    {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">pop</span>();
    }
  }
};
</code></pre>

</div>
</div><h3>The FragmentRepository class</h3>
<p>The <code>FragmentRepository</code> uses several helper classes, these we introduce right
before defining the repository class.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment repository&gt;&gt;=</div>
<div class="code">
<pre><code>&lt;&lt;fragment map&gt;&gt;
&lt;&lt;list <span class="hljs-keyword">of</span> grabbed states&gt;&gt;
&lt;&lt;fragment tag location&gt;&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentRepository</span> {
  &lt;&lt;fragment repository member variables&gt;&gt;
  &lt;&lt;fragment repository constructor&gt;&gt;
  &lt;&lt;fragment generation method&gt;&gt;

  &lt;&lt;method to get fragments <span class="hljs-keyword">from</span> repository&gt;&gt;

  &lt;&lt;method to get fragment on line <span class="hljs-keyword">for</span> position&gt;&gt;
  &lt;&lt;method to get token at position&gt;&gt;
  &lt;&lt;method to get state <span class="hljs-keyword">for</span> workspace&gt;&gt;
  &lt;&lt;method to get state <span class="hljs-keyword">for</span> <span class="hljs-variable language_">document</span>&gt;&gt;
  &lt;&lt;method to get all reference locations&gt;&gt;

  <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> fragmentMap <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">values</span>())
    {
      fragmentMap.<span class="hljs-title function_">dispose</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">clear</span>();

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> grabbedState <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">values</span>())
    {
      grabbedState.<span class="hljs-title function_">dispose</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">clear</span>();
  }
}
</code></pre>

</div>
</div><h4>Member variables</h4>
<p>Our <code>FragmentRepository</code> needs a couple of member variables to function
properly. We'll need an instance of a properly configured <em>MarkdownIt</em> parser.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment repository member variables&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">private</span> md : <span class="hljs-title class_">MarkdownIt</span>;
</code></pre>

</div>
</div><p>Since we work with a multi-root workspace we'll create a map of maps. The keys
for this top-level map will be the workspace folder names. The actual
<code>FragmentMap</code>s will be the values to each workspace folder.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment repository member variables&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">readonly</span> fragmentsForWorkspaceFolders : <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentMap</span>&gt;;
</code></pre>

</div>
</div><p>For our parsing functionality we need an <code>Array&lt;GrabbedState&gt;</code>, which we have
encapsulated in the class <code>GrabbedStateList</code> and is available through the <code>list</code>
property. Each <code>GrabbedStateList</code> is saved to the map of workspace folder name
and list key-value pair.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment repository member variables&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">readonly</span> grabbedStateForWorkspaceFolders : <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">GrabbedStateList</span>&gt;;
</code></pre>

</div>
</div><p>Finally we need a <code>DiagnosticCollection</code> to be able to keep track of detected
problems in <strong>literate</strong> projects. TBD: this probably needs to be changed into a
map of <code>DiagnosticCollection</code>, again with the workspace folder names as keys.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment repository member variables&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">readonly</span> diagnostics : vscode.<span class="hljs-property">DiagnosticCollection</span>;
</code></pre>

</div>
</div><h4>Constructor</h4>
<p>The constructor takes an extension context to register any disposables there.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment repository constructor&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">constructor</span>(<span class="hljs-params">
  context : vscode.ExtensionContext
</span>)
{
  &lt;&lt;initializing the fragment repository members&gt;&gt;

  &lt;&lt;subscribe to text <span class="hljs-variable language_">document</span> changes&gt;&gt;
  &lt;&lt;subscribe to workspace changes&gt;&gt;
  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
    vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">onDidChangeWorkspaceFolders</span>(
      <span class="hljs-keyword">async</span> (e : vscode.<span class="hljs-property">WorkspaceFoldersChangeEvent</span>) =&gt;
      {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> addedWorkspaceFolder <span class="hljs-keyword">of</span> e.<span class="hljs-property">added</span>) {
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processLiterateFiles</span>(addedWorkspaceFolder);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> removedWorkspaceFolder <span class="hljs-keyword">of</span> e.<span class="hljs-property">removed</span>)
        {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">delete</span>(removedWorkspaceFolder.<span class="hljs-property">name</span>);
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">delete</span>(removedWorkspaceFolder.<span class="hljs-property">name</span>);
        }
      }
    )
  );
}
</code></pre>

</div>
</div><h5>Initializing members</h5>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;initializing the fragment repository members&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">md</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentMap</span>&gt;();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">GrabbedStateList</span>&gt;();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span> = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate&#x27;</span>);
context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>);
</code></pre>

</div>
</div><h5>Subscribing to text document changes</h5>
<p>The repository subscribes to the <code>onDidChangeTextDocument</code> event on the
workspace. It could process <strong>literate</strong> files on each change, but the
completion item provider needs to trigger itself processing of literate files.
Since completion item provider gets called on typing a opening chevron (<code>&lt;</code>) we
skip triggering the processing here when such a character has been typed.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;subscribe to text document changes&gt;&gt;=</div>
<div class="code">
<pre><code>context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
  vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">onDidChangeTextDocument</span>(
    <span class="hljs-keyword">async</span> (e : vscode.<span class="hljs-property">TextDocumentChangeEvent</span>) =&gt;
    {
      <span class="hljs-keyword">if</span>(!(e.<span class="hljs-property">contentChanges</span>.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span> &amp;&amp; e.<span class="hljs-property">contentChanges</span>[<span class="hljs-number">0</span>].<span class="hljs-property">text</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;&lt;&#x27;</span>)))
      {
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processLiterateFiles</span>(e.<span class="hljs-property">document</span>);
      }
    }
  )
);
</code></pre>

</div>
</div><h5>Subscribing to workspace changes</h5>
<p>Triggering of processing <strong>literate</strong> documents is necessary when new workspace
folders have been added. Additionally we need to clean up fragment maps and
grabbed states for those workspace folders that have been removed from the
workspace folder.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;subscribe to workspace changes&gt;&gt;=</div>
<div class="code">
<pre><code>context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
  vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">onDidChangeWorkspaceFolders</span>(
    <span class="hljs-keyword">async</span> (e : vscode.<span class="hljs-property">WorkspaceFoldersChangeEvent</span>) =&gt;
    {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> addedWorkspaceFolder <span class="hljs-keyword">of</span> e.<span class="hljs-property">added</span>) {
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processLiterateFiles</span>(addedWorkspaceFolder);
      }
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> removedWorkspaceFolder <span class="hljs-keyword">of</span> e.<span class="hljs-property">removed</span>)
      {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">delete</span>(removedWorkspaceFolder.<span class="hljs-property">name</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">delete</span>(removedWorkspaceFolder.<span class="hljs-property">name</span>);
      }
    }
  )
);
</code></pre>

</div>
</div><h4>Processing literate files</h4>
<p>The parsing and setting up of the <code>fragments</code> map is handled with the method
<code>processLiterateFiles</code>. Additionally the method will write out all specified
source files.</p>
<p>Processing the literate files is started generally in one of three cases: 1) change
in workspace due to addition or removal of a workspace folder, 2) change to a
literate document or through triggering of the <code>literate.process</code> command.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment generation method&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-title function_">processLiterateFiles</span>(<span class="hljs-params">
  trigger :
    vscode.WorkspaceFolder
    | vscode.TextDocument
    | <span class="hljs-literal">undefined</span></span>) {
      &lt;&lt;set up workspace folder array&gt;&gt;
      &lt;&lt;iterate over workspace folders and parse&gt;&gt;
}
</code></pre>

</div>
</div><p>First we determine the workspace folder or workspace folders to process. In the
case where <code>trigger</code> is a workspace folder or a text document we use the given
workspace folder or determine the one to which the text document belongs. In
these cases we'll have an array with just the one workspace folder as element.
When the trigger is <code>undefined</code> we'll use all workspace folders registered to
this workspace.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;set up workspace folder array&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> workspaceFolders : <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">WorkspaceFolder</span>&gt; | <span class="hljs-literal">undefined</span> = (<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span>(trigger)
  {
    &lt;&lt;get workspace <span class="hljs-keyword">if</span> text <span class="hljs-variable language_">document</span>&gt;&gt;
    &lt;&lt;<span class="hljs-keyword">else</span> just use passed <span class="hljs-keyword">in</span> workspace&gt;&gt;
    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;eol&quot;</span> <span class="hljs-keyword">in</span> trigger) {
      <span class="hljs-keyword">const</span> ws = <span class="hljs-title function_">determineWorkspaceFolder</span>(trigger);
      <span class="hljs-keyword">if</span>(ws)
      {
        <span class="hljs-keyword">return</span> [ws];
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> [trigger];
    }
  }
  <span class="hljs-keyword">if</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> &amp;&amp; vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>) {
    <span class="hljs-keyword">let</span> folders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">WorkspaceFolder</span>&gt;();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ws <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>)
    {
      folders.<span class="hljs-title function_">push</span>(ws);
    }
    <span class="hljs-keyword">return</span> folders;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}
)();
</code></pre>

</div>
</div><p>We can check if our <code>trigger</code> is a <code>TextDocument</code> to see if <code>eol</code> is a property.
Otherwise it is a <code>Workspace</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;get workspace if text document&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;eol&quot;</span> <span class="hljs-keyword">in</span> trigger) {
  <span class="hljs-keyword">const</span> ws = <span class="hljs-title function_">determineWorkspaceFolder</span>(trigger);
  <span class="hljs-keyword">if</span>(ws)
  {
    <span class="hljs-keyword">return</span> [ws];
  }
}
</code></pre>

</div>
</div><p>When the property <code>eol</code> is not found in the objetc we were passed we can assume
it is just a workspace so return that as the one element in the array we return.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;else just use passed in workspace&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">else</span>
{
  <span class="hljs-keyword">return</span> [trigger];
}
</code></pre>

</div>
</div><p>With workspace folders available we can itherate over each folder and then
handle <strong>literate</strong> files in that wrokspace folder.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;iterate over workspace folders and parse&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span>(workspaceFolders) {
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> folder <span class="hljs-keyword">of</span> workspaceFolders)
  {
    &lt;&lt;set up fragments and grabbedStateList&gt;&gt;
    <span class="hljs-keyword">if</span>(fragments &amp;&amp; grabbedStateList) {
      &lt;&lt;clear <span class="hljs-title class_">FragmentMap</span> and <span class="hljs-title class_">GrabbedStateList</span>&gt;&gt;
      &lt;&lt;iterate over all files, write out html&gt;&gt;
      &lt;&lt;hanle fragments <span class="hljs-keyword">for</span> map&gt;&gt;
      &lt;&lt;extrapolate fragments and save out&gt;&gt;
    }
  }
}
</code></pre>

</div>
</div><p>First we ensure entries for our workspace exist in the maps for <code>FragmentMap</code>
and <code>GrabbedStateList</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;set up fragments and grabbedStateList&gt;&gt;=</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">has</span>(folder.<span class="hljs-property">name</span>))
    {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">set</span>(folder.<span class="hljs-property">name</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentMap</span>());
    }
    <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">has</span>(folder.<span class="hljs-property">name</span>))
    {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">set</span>(folder.<span class="hljs-property">name</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrabbedStateList</span>());
    }
</code></pre>

</div>
</div><p>Next we can get the <code>FragmentMap</code> and <code>GrabbedStateList</code> for our workspace
folder. These we'll fill up with the data of our <strong>literate</strong> project.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;set up fragments and grabbedStateList&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">const</span> fragments = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">get</span>(folder.<span class="hljs-property">name</span>);
    <span class="hljs-keyword">const</span> grabbedStateList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">get</span>(folder.<span class="hljs-property">name</span>);
</code></pre>

</div>
</div><p>Each time we process a <strong>literate</strong> project we clear out the fragments and state
so that we don't end up with stray elements.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;clear FragmentMap and GrabbedStateList&gt;&gt;=</div>
<div class="code">
<pre><code>fragments.<span class="hljs-title function_">clear</span>();
grabbedStateList.<span class="hljs-title function_">clear</span>();
</code></pre>

</div>
</div><p>Our first pass is iterating over all the <strong>literate</strong> files in our folder,
parsing them as we go. Each parsed file will be rendered as HTML and saved out
to disk. The parser state with all the tokens will be set to
<code>grabbedStateList.list</code>. We need to <code>await</code> on this <code>async</code> function, otherwise
our state will be incomplete. The full state is needed for the next two steps.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;iterate over all files, write out html&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(folder,
                            writeOutHtml,
                            grabbedStateList.<span class="hljs-property">list</span>,
                            <span class="hljs-variable language_">this</span>.<span class="hljs-property">md</span>);
</code></pre>

</div>
</div><p>With the state complete, and our HTML files saved out, we are going to do two
passes over the state. Lets do the first step here: we clear out the
diagnostics, and then await on <code>handleFragments</code>. This function we call such
that there is no extrapolation of fragments, nor source files are going to be
saved. We <code>await</code> for the function to complete, otherwise our fragment map will
be incomplete, or even just missing later on.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;hanle fragments for map&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>.<span class="hljs-title function_">clear</span>();
fragments.<span class="hljs-property">map</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(folder,
                                      grabbedStateList.<span class="hljs-property">list</span>,
                                      <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>,
                                      <span class="hljs-literal">false</span>,
                                      <span class="hljs-literal">undefined</span>);
</code></pre>

</div>
</div><p>The second step we'll call the fragment handler again, but this time we <em>do</em>
want the fragments to be completely extrapolated, and the final source files
written to disk. Before the call we again clear out the <code>DiagnosticCollection</code>
so that we get the correct diagnostics in case of errors in <strong>literate</strong> files.</p>
<p>Again we wait for the results, just to ensure it all completes before we go on.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;extrapolate fragments and save out&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>.<span class="hljs-title function_">clear</span>();
<span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(folder, grabbedStateList.<span class="hljs-property">list</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>, <span class="hljs-literal">true</span>, writeSourceFiles);
</code></pre>

</div>
</div><h4>Fetching fragments for workspace folder</h4>
<p>When we call <code>getFragments</code> we assume the <strong>literate</strong> projects have all been
process properly. In most cases that is triggered automatically, but it may be
necessary to trigger the processing manually before calling <code>getFragments</code>. When
the projects have been properly processed, though, this function returns the
<code>FragmentMap</code> for the given workspace folder.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get fragments from repository&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">getFragments</span>(workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>) : <span class="hljs-title class_">FragmentMap</span>
{
<span class="hljs-keyword">let</span> fragmentMap : <span class="hljs-title class_">FragmentMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentMap</span>();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentsForWorkspaceFolders</span>.<span class="hljs-title function_">forEach</span>(
  <span class="hljs-function">(<span class="hljs-params">value, key, _</span>) =&gt;</span>
  {
    <span class="hljs-keyword">if</span>(key === workspaceFolder.<span class="hljs-property">name</span>)
    {
      fragmentMap = value;
      }
    }
  );

  <span class="hljs-keyword">return</span> fragmentMap;
}
</code></pre>

</div>
</div><h4>Getting fragment on line for position</h4>
<p>This method checks to see if for the given text line and position a fragment
usage or mention can be found.</p>
<p>First we find matches on the current line against <code>FRAGMENT_USE_IN_CODE_RE</code>. In
all matches we check which of them is at the given position. We do that by
searching for the index of the match tag name, including the double chevron
bracketing.</p>
<p>The range for the <code>FragmentLocation</code> will be created from the found index and
run the length of the tag name including the double enclosing chevrons. An
attempt to find the corresponding fragment is made, but if no such fragment
exists the <code>FragmentLocation</code> will be created with the fragment set to
<code>undefined</code>. The <code>root</code> and <code>add</code> parts are also given to the fragment location,
even if they were not matched. This information can be used elsewhere to
determine what kind of fragment was found at the given position.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get fragment on line for position&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">getFragmentTagLocation</span>(
  <span class="hljs-variable language_">document</span> : vscode.<span class="hljs-property">TextDocument</span>,
  currentLine : vscode.<span class="hljs-property">TextLine</span>,
  position : vscode.<span class="hljs-property">Position</span>
) : <span class="hljs-title class_">FragmentLocation</span>
{
  <span class="hljs-keyword">const</span> workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-variable language_">document</span>);
  <span class="hljs-keyword">const</span> matchesOnLine = [...currentLine.<span class="hljs-property">text</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matchesOnLine)
  {
    <span class="hljs-keyword">if</span>(!match || !match.<span class="hljs-property">groups</span>) {
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">const</span> tagName = <span class="hljs-string">`<span class="hljs-subst">${OPENING}</span><span class="hljs-subst">${match.groups.tagName}</span><span class="hljs-subst">${CLOSING}</span>`</span>;
    <span class="hljs-keyword">const</span> foundIndex = currentLine.<span class="hljs-property">text</span>.<span class="hljs-title function_">indexOf</span>(tagName);
    <span class="hljs-keyword">if</span>(foundIndex&gt;-<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">if</span>(foundIndex &lt;= position.<span class="hljs-property">character</span> &amp;&amp; position.<span class="hljs-property">character</span> &lt;= foundIndex + tagName.<span class="hljs-property">length</span>)
      {
        <span class="hljs-keyword">const</span> startPosition = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(currentLine.<span class="hljs-property">lineNumber</span>, foundIndex);
        <span class="hljs-keyword">const</span> endPosition = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(currentLine.<span class="hljs-property">lineNumber</span>, foundIndex + tagName.<span class="hljs-property">length</span>);
        <span class="hljs-keyword">let</span> range : vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(startPosition, endPosition);
        <span class="hljs-keyword">let</span> fragment : <span class="hljs-title class_">FragmentInformation</span> | <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">if</span>(workspaceFolder) {
          <span class="hljs-keyword">const</span> fragments = theOneRepository.<span class="hljs-title function_">getFragments</span>(workspaceFolder).<span class="hljs-property">map</span>;
          fragment = fragments.<span class="hljs-title function_">get</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>) || <span class="hljs-literal">undefined</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentLocation</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">uri</span>, range, fragment, match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>, match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>);
      }
    }
  }

  <span class="hljs-keyword">return</span> unsetFragmentLocation;
}
</code></pre>

</div>
</div><h5>The FragmentLocation</h5>
<p>A fragment location encodes the occurrence of what could be a fragment that
already exists or one that still needs to be defined. The class holds the name
of the fragment, the range of this string in the resource specified by the uri,
and whether a <code>FragmentInformation</code> was found or not.</p>
<p>The properties <code>root</code> and <code>add</code> can be used to determine what type of fragment
is at the given range.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment tag location&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentLocation</span>
{
  <span class="hljs-keyword">readonly</span> rangeExclusive : vscode.<span class="hljs-property">Range</span>;
  <span class="hljs-keyword">readonly</span> valid : <span class="hljs-built_in">boolean</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> name : <span class="hljs-built_in">string</span>,
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> uri: vscode.Uri,
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> range : vscode.Range,
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> fragment : FragmentInformation | <span class="hljs-literal">undefined</span>,
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> root : <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>,
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> add : <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>
  </span>)
  {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">valid</span> = uri.<span class="hljs-property">fsPath</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;not_valid_for_literate&#x27;</span>)===-<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(name.<span class="hljs-title function_">startsWith</span>(<span class="hljs-variable constant_">OPENING</span>)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">rangeExclusive</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(
        range.<span class="hljs-property">start</span>.<span class="hljs-property">line</span>, range.<span class="hljs-property">start</span>.<span class="hljs-property">character</span> + <span class="hljs-number">2</span>,
        range.<span class="hljs-property">end</span>.<span class="hljs-property">line</span>, range.<span class="hljs-property">end</span>.<span class="hljs-property">character</span> - <span class="hljs-number">2</span>
      );
    }
    <span class="hljs-keyword">else</span>
    {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">rangeExclusive</span> = range;
    }
  }
}
<span class="hljs-keyword">const</span> unsetFragmentLocation =
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentLocation</span>(
      <span class="hljs-string">&#x27;&#x27;</span>,
      vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">file</span>(<span class="hljs-string">&#x27;not_valid_for_literate&#x27;</span>),
      <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),
      <span class="hljs-literal">undefined</span>,
      <span class="hljs-literal">undefined</span>,
      <span class="hljs-literal">undefined</span>
    );
</code></pre>

</div>
</div><h4>Get fragment usage token</h4>
<p>This method takes a text document and a range, based on which the token
containing the range is returned. If no token is found, or the workspace folder
is not available the <code>emptyToken</code> constant is returned.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get token at position&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">getTokenAtPosition</span>(
  <span class="hljs-variable language_">document</span> : vscode.<span class="hljs-property">TextDocument</span>,
  range : vscode.<span class="hljs-property">Range</span>
) : <span class="hljs-title class_">TokenUsage</span>
{
</code></pre>

</div>
</div><p>Determine the workspace folder for the given text document. As mentioned above,
is no workspace folder is found the <code>emptyToken</code> is returned.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get token at position&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">const</span> workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-variable language_">document</span>);
  <span class="hljs-keyword">if</span>(!workspaceFolder)
  {
    <span class="hljs-keyword">return</span> emptyToken;
  }
</code></pre>

</div>
</div><p>Next we can retrieve the state for the document.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get token at position&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">const</span> state = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getDocumentState</span>(<span class="hljs-variable language_">document</span>);
</code></pre>

</div>
</div><p>We can iterate over all the tokens in the grabbed state of the document. We're
only interested in tokens that have a valid <code>map</code> property, since we need to
check the range asked for.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get token at position&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> token <span class="hljs-keyword">of</span> state.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>)
  {
    <span class="hljs-keyword">if</span>(token.<span class="hljs-property">map</span>) {
</code></pre>

</div>
</div><p>If the range given is contained within the token map we create a new TokenUsage
and return that. This concludes the search for the token containing the range we
are interested in.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get token at position&gt;&gt;=+</div>
<div class="code">
<pre><code>      <span class="hljs-keyword">const</span> tokenRange = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, token.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1024</span>);
      <span class="hljs-keyword">if</span>(tokenRange.<span class="hljs-title function_">contains</span>(range))
      {
        <span class="hljs-keyword">let</span> tokenUsage : <span class="hljs-title class_">TokenUsage</span> = {
          token : token,
        };
        <span class="hljs-keyword">return</span> tokenUsage;
      }
    }
  }
</code></pre>

</div>
</div><p>If no hit was found return the <code>emptyToken</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get token at position&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">return</span> emptyToken;
}
</code></pre>

</div>
</div><p>The <code>TokenUsage</code> interface helps determining whether we have a token or not.
TBD: we can probably get rid of this interface and just use a <code>Token</code> directly.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;token usage interface&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TokenUsage</span>
{
  token : <span class="hljs-title class_">Token</span> | <span class="hljs-literal">undefined</span>,
}

<span class="hljs-keyword">const</span> emptyToken : <span class="hljs-title class_">TokenUsage</span> =
{
  token : <span class="hljs-literal">undefined</span>,
};
</code></pre>

</div>
</div><h4>Get list of grabbed states for a workspace</h4>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get state for workspace&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">getWorkspaceState</span>(workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>) : <span class="hljs-title class_">GrabbedStateList</span>
{
  <span class="hljs-keyword">let</span> grabbedState : <span class="hljs-title class_">GrabbedStateList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrabbedStateList</span>();
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">grabbedStateForWorkspaceFolders</span>.<span class="hljs-title function_">forEach</span>(
    <span class="hljs-function">(<span class="hljs-params">value, key, _</span>) =&gt;</span>
    {
      <span class="hljs-keyword">if</span>(key === workspaceFolder.<span class="hljs-property">name</span>)
      {
        grabbedState = value;
        }
      }
    );

  <span class="hljs-keyword">return</span> grabbedState;
}
</code></pre>

</div>
</div><h4>Get the grabbed state of a document</h4>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get state for document&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">getDocumentState</span>(<span class="hljs-attr">document</span>: vscode.<span class="hljs-property">TextDocument</span>) : <span class="hljs-title class_">GrabbedState</span>
{
  <span class="hljs-keyword">let</span> grabbedState : <span class="hljs-title class_">GrabbedState</span> = emptyState;
  <span class="hljs-keyword">const</span> ws = <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-variable language_">document</span>);
  <span class="hljs-keyword">if</span>(ws) {
    <span class="hljs-keyword">const</span> workspaceState = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWorkspaceState</span>(ws);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> state <span class="hljs-keyword">of</span> workspaceState.<span class="hljs-property">list</span>)
    {
      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">uri</span>.<span class="hljs-property">path</span> === state.<span class="hljs-property">literateUri</span>.<span class="hljs-property">path</span>)
      {
        grabbedState = state;
      }
    }
  }

  <span class="hljs-keyword">return</span> grabbedState;
}
</code></pre>

</div>
</div><h4>Get all reference locations</h4>
<p>Finding all references for a fragment, that is fragment usage or fragment
mention in a <strong>literate</strong> project will go over all tokens of a workspace. For
each reference a <code>vscode.Location</code> is returned.</p>
<p>The <code>getReferenceLocations</code> method takes a workspace folder and a fragment name,
and will return an array of <code>vscode.Location</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-title function_">getReferenceLocations</span>(
  workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>,
  fragmentName : <span class="hljs-built_in">string</span>
) : vscode.<span class="hljs-property">Location</span>[]
{
</code></pre>

</div>
</div><p>We start with an empty list of locations, which we will fill for each reference
hit we determine in the given <strong>literate</strong> project. For the workspace folder we
get the latest grabbed state.</p>
<p>We then will proceed to iterate through all grabbed states. Remember that each
grabbed state corresponds to a <strong>literate</strong> document. From that grabbed state we
will iterate over each token, and we'll be interested only in the tokens that
have a valid <code>map</code> property.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">const</span> fragmentTag = <span class="hljs-variable constant_">OPENING</span>+fragmentName+<span class="hljs-variable constant_">CLOSING</span>;
  <span class="hljs-keyword">let</span> locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">Location</span>&gt;();
  <span class="hljs-keyword">let</span> grabbedStateList = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWorkspaceState</span>(workspaceFolder).<span class="hljs-property">list</span>;

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> grabbedState <span class="hljs-keyword">of</span> grabbedStateList)
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> token <span class="hljs-keyword">of</span> grabbedState.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>)
    {
      <span class="hljs-keyword">if</span>(token.<span class="hljs-property">map</span>)
      {
</code></pre>

</div>
</div><p>When we have a token that could contain a reference we'll see if there is any
occurrence of the fragment tag, otherwise the content has no reference.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>        <span class="hljs-keyword">if</span>(token.<span class="hljs-property">content</span>.<span class="hljs-title function_">indexOf</span>(fragmentTag) &gt; -<span class="hljs-number">1</span>)
        {
</code></pre>

</div>
</div><p>With a hit in the entire content of the token we need to figure out each
reference, which we do by splitting the token content into lines if there are
any new line characters, then for each line look at each hit.</p>
<p>If our token is a <code>fence</code> we initialize <code>idx</code> to 1, otherwise to 0.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>          <span class="hljs-keyword">const</span> lines = token.<span class="hljs-property">content</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>);
          <span class="hljs-keyword">let</span> idx = token.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;fence&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {
            <span class="hljs-keyword">let</span> offset = line.<span class="hljs-title function_">indexOf</span>(fragmentTag);
            <span class="hljs-keyword">while</span>(offset&gt;-<span class="hljs-number">1</span>) {
</code></pre>

</div>
</div><p>When offset is larger than -1 we know we have a hit, so we can create a new
range using the <code>token.map[0]</code> and the <code>idx</code>. The range will include the entire
fragment tag, with the opening and closing double chevrons.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>              <span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(
                token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>] + idx,
                offset,
                token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>] + idx,
                offset + fragmentTag.<span class="hljs-property">length</span>
              );
</code></pre>

</div>
</div><p>The location then is created with the uri of the <strong>literate</strong> file that contains
this token, and the rnge we just set up.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>              <span class="hljs-keyword">let</span> location = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Location</span>(grabbedState.<span class="hljs-property">literateUri</span>, range);
              locations.<span class="hljs-title function_">push</span>(location);
</code></pre>

</div>
</div><p>We chech for the next occurrance of the fragment tag by looking enough
characters past the current offset. That way we'll ensure we get to all the
references if there are multiple on one line.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>              offset = line.<span class="hljs-title function_">indexOf</span>(fragmentTag, offset + <span class="hljs-number">5</span>);
            }
</code></pre>

</div>
</div><p>Update <code>idx</code> for each pass while going through the lines array.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>            idx++;
          }
        }
      }
    }
  }
</code></pre>

</div>
</div><p>Return the <code>locations</code> array. If there were hits the <code>locations</code> array will have
entries, if there were no hits the array will be empty.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;method to get all reference locations&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">return</span> locations;
}
</code></pre>

</div>
</div><h2>Iterating all literate files</h2>
<p>As mentioned in the introduction the main idea of the extension is to collect
all fragments that are created in all <code>.literate</code> files. Once all fragments have
been collected they are extrapolated until the top fragments are the full source
files. Fully extrapolated top fragments are written to the source files as
specicied for them.</p>
<p>The first step is to put each <code>.literate</code> file through the <em>MarkdownIt</em>
renderer. Each rendering will be given a special environment that will be used
to collect the state for the render. The state will contain the document
tokenized according the Markdown specification. The state <code>env</code> is of type
<code>GrabbedState</code>. Among the tokens will be the code fences that are code
fragments. For each <code>.literate</code> file the grabbed state <code>env</code> is saved in the
list of <code>GrabbedState</code>s <code>envList</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;render and collect state&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">iterateLiterateFiles</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder,
                                    writeHtml : WriteRenderCallback
                                                | <span class="hljs-literal">undefined</span>
                                                | <span class="hljs-literal">null</span>,
                                    envList : <span class="hljs-built_in">Array</span>&lt;GrabbedState&gt;,
                                    md : MarkdownIt</span>)
{
  &lt;&lt;find all literate files <span class="hljs-keyword">in</span> workspace&gt;&gt;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fl <span class="hljs-keyword">of</span> foundLiterateFiles) {
      &lt;&lt;get text <span class="hljs-keyword">from</span> literate <span class="hljs-variable language_">document</span>&gt;&gt;
      &lt;&lt;parse literate file&gt;&gt;
      &lt;&lt;write out rendered file <span class="hljs-keyword">if</span> requested&gt;&gt;
    }
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);
  }
}
</code></pre>

</div>
</div><p>We ensure that only <strong>literate</strong> files are going to be parsed for their program
fragments. We do that by using a <code>vscode.RelativePattern</code> using the workspace
folder passed into <code>iterateLiterateFiles</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;find all literate files in workspace&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> foundLiterateFiles = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getLiterateFileUris</span>(workspaceFolder);
</code></pre>

</div>
</div><p>We get the content of our <strong>literate</strong> file using <code>getFileContent</code>. We do need
to <code>await</code> for that so that we actually get the string and not a promise.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;get text from literate document&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getFileContent</span>(fl);
</code></pre>

</div>
</div><p>With the <code>text</code> for our <strong>literate</strong> document ready we harvest the relative file
path to our document from the workspace folder. <code>fname</code> is then set as the
<code>literateFileName</code> of our <code>GrabbedState</code> instance that we push into the
<code>envList</code> so that we can access it later. Now we finally get to pass the <code>text</code>
of our <strong>literate</strong> document to the <em>MarkdownIt</em> renderer. Once that is done we
have both an HTML representation of our document as well as the entire parser
state in <code>env</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;parse literate file&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> fname = path.<span class="hljs-title function_">relative</span>(workspaceFolder.<span class="hljs-property">uri</span>.<span class="hljs-property">path</span>, fl.<span class="hljs-property">path</span>);
<span class="hljs-keyword">const</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span> = { <span class="hljs-attr">literateFileName</span>: fname, <span class="hljs-attr">literateUri</span>: fl, <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, md, {}) };
envList.<span class="hljs-title function_">push</span>(env);
<span class="hljs-keyword">const</span> rendered = md.<span class="hljs-title function_">render</span>(text, env);
</code></pre>

</div>
</div><p>If a callback implementing <code>WriteRenderCallback</code> is passed to
<code>iterateLiterateFiles</code> we call that with the endered file content so that it can
be saved as an <code>HTML</code> file with the same name as the <code>.literate</code> file that was
being rendered, but with the extension replaced with <code>.html</code>. Conversely, if no
callback was passed in it is not called and rendered results are not saved to
disk.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;write out rendered file if requested&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span>(writeHtml)
{
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">writeHtml</span>(fname, workspaceFolder.<span class="hljs-property">uri</span>, rendered);
}
</code></pre>

</div>
</div><h3>GrabbedState interface</h3>
<p>The <code>GrabbedState</code> interface is used to create a type that helps us collecting
the tokens for each <code>.literate</code> file. Instances of objects with this interface
are passed to a <em>MarkdownIt</em> renderer. The renderer will have the
<code>GrabberPlugin</code> registered, which provides a rule that helps us collecting the
states of each rendered file. The grabbed state is collected in <code>gstate</code>, which
is an instance of the <code>StateCore</code>, provided by <em>MarkdownIt</em>.</p>
<p>The interface defines <code>literateFileName</code>, which is the filename of the
<strong>literate</strong> document to which the grabbed state belongs. <code>literateUri</code> is the
full uri for this document. Finally <code>gstate</code> holds the <code>StateCore</code> of the
parsing result.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;grabbed state type&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GrabbedState</span> {
  <span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">literateUri</span>: vscode.<span class="hljs-property">Uri</span>;
  <span class="hljs-attr">gstate</span>: <span class="hljs-title class_">StateCore</span>;
}
</code></pre>

</div>
</div><p>We define a <code>GrabbedState</code> that is not valid, the <code>emptyState</code>. This allows us
to always return an object instead of <code>undefined</code> in select cases.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;grabbed state type&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> emptyState : <span class="hljs-title class_">GrabbedState</span> =
{
  literateFileName : <span class="hljs-string">&#x27;&#x27;</span>,
  literateUri : vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">file</span>(<span class="hljs-string">&#x27;not_valid_for_literate&#x27;</span>),
  <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-title function_">createMarkdownItParserForLiterate</span>(), <span class="hljs-string">&#x27;&#x27;</span>)
};
</code></pre>

</div>
</div><h2>Preparing MarkdownIt</h2>
<p>In the <code>iterateLiterateFiles</code> we start by setting up the <em>MarkdownIt</em> parser.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;set up MarkdownIt&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
</code></pre>

</div>
</div><p>The function <code>createMarkdownItParserForLiterate</code> does this setup so that it is
easy to get a new parser to use for different purposes, like parsing documents
to get the code fragment names for code completion.</p>
<p>The highlight function we use to ensure our code fragments get syntax
highlighting. This simply relies on <em>highlight.js</em> to do the work.</p>
<p>We also tell <em>MarkdownIt</em> to use our <code>grabberPlugin</code>. This plug-in harvests the
internal states for each document into instances of <code>GrabbedState</code>. These states
we'll later use to get all the different code fragments and to weave them into
the code files they describe.</p>
<p>Finally we replace the default <code>fence</code> rule with our own <code>renderCodeFence</code> rule.
The intent of that rule will be explained in the section on <code>renderCodeFence</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create markdownit parser&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createMarkdownItParserForLiterate</span>(<span class="hljs-params"></span>) : <span class="hljs-title class_">MarkdownIt</span>
{
  <span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
          <span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, lang: <span class="hljs-built_in">string</span>, attrs: <span class="hljs-built_in">string</span></span>) {
            <span class="hljs-keyword">if</span>(lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&lt;code&gt;&#x27;</span> +
              hljs.<span class="hljs-title function_">highlight</span>(str, {language : lang}).<span class="hljs-property">value</span> +
              <span class="hljs-string">&#x27;&lt;/code&gt;&lt;/pre&gt;&#x27;</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre title=&quot;&#x27;</span> + attrs + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span> + md.<span class="hljs-property">utils</span>.escapeHtml(str) + <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>;
          }

        })
        .<span class="hljs-title function_">use</span>(grabberPlugin);

      oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
      md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
  <span class="hljs-keyword">return</span> md;
}
</code></pre>

</div>
</div><h2>Fragment structure and regular expressions</h2>
<p>Before we dive deeper into the processing of <code>.literate</code> documents it is
necessary to have a look at how fragments work.</p>
<p>Fragments in the <code>literate</code> extension have a specific format that requires a bit
of explaining.</p>
<p>There are four types of fragment tags, three of which either create or modify a
fragment, and one that expresses fragment usage.</p>
<p>For the detection of fragments a couple of regular expressions are used. These
are explained in more detail below.</p>
<h3>Fragment use in code</h3>
<p>Lets start by looking at the form for fragment tag use.</p>
<p>Fragments can be used in code blocks by using their tag double opening and
closing chevrons around the fragment name <code>&lt;&lt;fragment name&gt;&gt;</code>. To detect usage
of fragments in code we use <code>FRAGMENT_USE_IN_CODE_RE</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment regular expressions&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-comment">//let HTML_ENCODED_FRAGMENT_TAG_RE = /(&amp;lt;&amp;lt.*?&amp;gt;&amp;gt;)/g;</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span> =
  <span class="hljs-regexp">/(?&lt;indent&gt;[ \t]*)&lt;&lt;(?&lt;tagName&gt;.+)&gt;&gt;(?&lt;root&gt;=)?(?&lt;add&gt;\+)?/g</span>;
</code></pre>

</div>
</div><p>The regular expression captures four groups. A match will give us 5 or more
results, the whole string matched and the captured groups. There may be some
additional parts after that, but those we will discard. The whole string matched
is called the <code>tag</code>. The first group is called <code>indent</code>, which will be used to
indent the whole fragment code when it gets extrapolated into the final code.
The second group is called <code>tagName</code>, which is the fragment name. The third
group is called <code>root</code> and the final group is called <code>add</code>. For fragment use we
essentially need only the second group <code>tagName</code>, with the <code>indent</code> still
serving a function. The other groups are in the regular expression so we can
identify incorrect use of fragments in code: creating or adding to fragments
inside code blocks is not valid.</p>
<p>The application of <code>FRAGMENT_USE_IN_CODE_RE</code> is explained in more detail in the
section on code realization.</p>
<h3>Creating and modifying fragments</h3>
<p>There is the tag used to create a new fragment, which is always in conjunction
with the opening code fence tag. This means either a triple backtick or triple
tilde followed by the programming language identifier for the following code
block. The actual fragment tag is placed as first option right after the colon
following the language specifier.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment regular expressions&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FRAGMENT_RE</span> =
  <span class="hljs-regexp">/(?&lt;lang&gt;.*):.*&lt;&lt;(?&lt;tagName&gt;.+)&gt;&gt;(?&lt;root&gt;=)?(?&lt;add&gt;\+)?\s*(?&lt;fileName&gt;.*)/</span>;
</code></pre>

</div>
</div><p>Most of the groups correspond to the ones defined by <code>FRAGMENT_USE_IN_CODE_RE</code>
with a few additions. Most notably there is the group catching the language
specifier, and the group to catch the filename, called <code>lang</code> and <code>fileName</code>
respectively.</p>
<p>So to create a new tag the info line for the code fence could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=</code>.</p>
<p>To add to a fragment a <code>+</code> is added, so it could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=+</code>. Having a fragment without <code>=</code> or <code>=+</code> on the code
fence info line is an error.</p>
<h2>Gathering all fragments</h2>
<p>All code fragments are fetched from each environment state. This is done through
looking for all <code>fence</code> tokens. If the <code>token.info</code> for a <code>fence</code> matches the
<code>FRAGMENT_RE</code> we can check to see whether the fragment we have currently in our
hands is a new fragment (<code>root &amp;&amp; !add</code>) or whether this one expands an existing
one (<code>root &amp;&amp; add</code>), as will be explained in more detail further down.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;handle fragments&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFragments</span>(<span class="hljs-params">
  workspaceFolder : vscode.WorkspaceFolder,
  envList : <span class="hljs-built_in">Array</span>&lt;GrabbedState&gt;,
  diagnostics : vscode.DiagnosticCollection,
  extrapolateFragments : <span class="hljs-built_in">boolean</span>,
  writeSource : WriteSourceCallback | <span class="hljs-literal">undefined</span></span>) : <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;&gt;
{
  <span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
  &lt;&lt;build fragment map&gt;&gt;

  <span class="hljs-keyword">if</span>(extrapolateFragments)
  {
    &lt;&lt;extrapolate fragments&gt;&gt;
  }

  <span class="hljs-keyword">if</span>(writeSource) {
    <span class="hljs-title function_">writeSource</span>(workspaceFolder, fragments);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(fragments);
}
</code></pre>

</div>
</div><div class="codefragment">
<div class="fragmentname">&lt;&lt;write out source files&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">writeSourceFiles</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder,
                fragments : <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, FragmentInformation&gt;</span>)
{
  <span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
  <span class="hljs-comment">/* now write out the source files. */</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
    <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">if</span> (fragmentInfo) {
        <span class="hljs-keyword">let</span> fileName = fragmentInfo.<span class="hljs-property">sourceFileName</span>.<span class="hljs-title function_">trim</span>();
        <span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(fragmentInfo.<span class="hljs-property">code</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
        <span class="hljs-keyword">const</span> fileUri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">joinPath</span>(folderUri, fileName);
        <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
      }
    }
  }
}
</code></pre>

</div>
</div><h3>Populating the fragment map</h3>
<p>First we build a map of all available fragments. These will go into <code>fragments</code>,
which is of type <code>Map&lt;string, FragmentInformation&gt;</code>. The name of a fragment will
function as the key, and an instance of <code>FragmentInformation</code> will be the value.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;build fragment map&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;();
<span class="hljs-keyword">const</span> overwriteAttempts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">const</span> missingFilenames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">const</span> addingToNonExistant = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> env <span class="hljs-keyword">of</span> envList) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> token <span class="hljs-keyword">of</span> env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>) {
    &lt;&lt;handle fence tokens&gt;&gt;
  }
}
</code></pre>

</div>
</div><p>Each <code>fence</code> token we find we need to check. There may be of course code fences
in the document that do not create or modify a fragment. These we need to skip.</p>
<p>Since we are handling code fences we use <code>FRAGMENT_RE</code> to match <code>token.info</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;handle fence tokens&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span>) {
  <span class="hljs-keyword">const</span> linenumber = <span class="hljs-title function_">locationOfFragment</span>(token);
  <span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
  <span class="hljs-keyword">if</span> (match &amp;&amp; match.<span class="hljs-property">groups</span>) {
    <span class="hljs-keyword">let</span> lang = match.<span class="hljs-property">groups</span>.<span class="hljs-property">lang</span>.<span class="hljs-title function_">trim</span>();
    <span class="hljs-keyword">let</span> name = match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>;
    <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
    <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
    <span class="hljs-keyword">let</span> fileName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">fileName</span>;
    &lt;&lt;add to existing fragment&gt;&gt;
    &lt;&lt;create a <span class="hljs-keyword">new</span> fragment&gt;&gt;
  }
}
</code></pre>

</div>
</div><h3>Creating a new fragment</h3>
<p>If the <code>root</code> group has captured a result but not the <code>add</code> group we know we
have a new fragment on our hand.</p>
<p>If we already have in our <code>fragments</code> map a key with the same <code>name</code> as the
fragment we are currently handling we add an error diagnostic message. We don't
stop handling fences, or the entire <code>literate.process</code> command for that matter.
We keep on going, but leave it up to the programmer to see and handle the error
messages.</p>
<p>If a fragment name with <code>.*</code> is found we need to ensure there is a result in the
<code>fileName</code> capture group. That is going to be needed to write out the source
code file eventually. A file defining fragment without a file name is an error.</p>
<p>When everything appears to be in order a new <code>FragmentInformation</code> instance is
created with the information found. The code for this fragment is the token
content in <code>token.content</code>. Finally the new <code>FragmentInformation</code> instance is
added to the <code>fragments</code> map.</p>
<p>If a new fragment is going to be created, but it already exists in the fragment
map we emit an error diagnostic. To ensure we emit the error diagnostic only
once the fragment name is added to <code>overwriteAttempts</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create a new fragment&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; !add) {
  <span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
    <span class="hljs-keyword">if</span>(!overwriteAttempts.<span class="hljs-title function_">includes</span>(name))
    {
      <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to overwrite existing fragment fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span><span class="hljs-subst">${linenumber}</span>`</span>;
      <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
      <span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
      overwriteAttempts.<span class="hljs-title function_">push</span>(name);
    }
  }
</code></pre>

</div>
</div><p>If it does not yet exist in the fragment map we can proceed. We need to check
though if we have a top-level fragment. In that case we require a file name, so
emit an error diagnostic when that is missing.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create a new fragment&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (!fileName &amp;&amp; name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt; -<span class="hljs-number">1</span> ) {
      <span class="hljs-keyword">if</span>(!missingFilenames.<span class="hljs-title function_">includes</span>(name)) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Expected filename for star fragment <span class="hljs-subst">${name}</span>`</span>;
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
        <span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
        missingFilenames.<span class="hljs-title function_">push</span>(name);
      }
    }
</code></pre>

</div>
</div><p>We can now finally create the <code>FragmentInformation</code> instance and add it to our
fragment map.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create a new fragment&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">let</span> code = token.<span class="hljs-property">content</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">fragmentInfo</span>: <span class="hljs-title class_">FragmentInformation</span> = {
      <span class="hljs-attr">lang</span>: lang,
      <span class="hljs-attr">literateFileName</span>: env.<span class="hljs-property">literateFileName</span>,
      <span class="hljs-attr">sourceFileName</span>: fileName,
      <span class="hljs-attr">code</span>: code,
      <span class="hljs-attr">tokens</span>: [token],
      <span class="hljs-attr">env</span>: env,
    };
    fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
  }
}
</code></pre>

</div>
</div><h3>Modifying an existing fragment</h3>
<p>If both the <code>root</code> and <code>add</code> groups have capture their results, an <code>=</code> and an
<code>+</code> respectively we need to add code to an existing fragment.</p>
<p>For this to work a new fragment needs to be always present before the modifying
fragment. It is an error to try to modify a fragment that hasn't been seen yet.</p>
<p>The fragment with specified <code>name</code> is fetched, and when it is not <code>undefined</code>
the <code>token.content</code> is appended to the <code>code</code> of the <code>FragmentInformation</code>
instance we got from the map. The current token is also appended to the <code>tokens</code>
list.</p>
<p>The fragments map is updated with the modified  <code>FragmentInformation</code> instance.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;add to existing fragment&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; add) {
  <span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
    <span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">if</span>(fragmentInfo &amp;&amp; fragmentInfo.<span class="hljs-property">code</span>) {
      <span class="hljs-keyword">let</span> additionalCode = token.<span class="hljs-property">content</span>;
      fragmentInfo.<span class="hljs-property">code</span> = <span class="hljs-string">`<span class="hljs-subst">${fragmentInfo.code}</span><span class="hljs-subst">${additionalCode}</span>`</span>;
      fragmentInfo.<span class="hljs-property">tokens</span>.<span class="hljs-title function_">push</span>(token);
      fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(!addingToNonExistant.<span class="hljs-title function_">includes</span>(name)) {
      <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to add to non-existant fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span>:<span class="hljs-subst">${linenumber}</span>`</span>;
      <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
      <span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
      addingToNonExistant.<span class="hljs-title function_">push</span>(name);
    }
  }
}
</code></pre>

</div>
</div><h3>The FragmentInformation type</h3>
<p>We have now seen the <code>FragmentInformation</code> type being used several times, so it
is important to take a moment to clarify it in more detail.</p>
<p>The interface allows us to gather information for each found code fragment. It
allows us to store the programming language identifier, name of the <code>.literate</code>
file and name of the targeted source file, if the code fragment happens to be a
top fragment.</p>
<p>The actual code for the fragment is stored in <code>code</code>. Furthermore the tokens for
the complete fragment are stored in the <code>tokens</code> list. This list is of objects
that fullfill the <code>Token</code> interface, which is provided by the <em>MarkdownIt</em>
module.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;fragment information type&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-comment">/**
 * Interface denoting a fragment and related information
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FragmentInformation</span> {
  <span class="hljs-comment">/**
   * Programming language identifier for fragment.
   */</span>
  <span class="hljs-attr">lang</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * Filename of literate file.
   */</span>
  <span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * Filename of target source file. This is set when the fragment
   * is a top fragment.
   */</span>
  <span class="hljs-attr">sourceFileName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * The code fragment.
   */</span>
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * List of tokens that make up the entire code fragment.
   */</span>
  <span class="hljs-attr">tokens</span>: <span class="hljs-title class_">Token</span>[];
  <span class="hljs-comment">/**
   * The GrabbedState related to this fragment.
   */</span>
  <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span>;
}
</code></pre>

</div>
</div><h2>Extrapolating fragments</h2>
<p>Once all fragments have been collected from the <code>.literate</code> files of the project
fragments can be combined into source code.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;extrapolate fragments&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-comment">// for now do several passes</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pass</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> rootIncorrect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">const</span> addIncorrect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">const</span> fragmentNotFound = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">do</span> {
  pass++;
  <span class="hljs-keyword">let</span> fragmentReplaced = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
    <span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">if</span> (!fragmentInfo) {
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
      <span class="hljs-keyword">if</span>(!match || !match.<span class="hljs-property">groups</span>) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">let</span> tag = match[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">let</span> indent = match.<span class="hljs-property">groups</span>.<span class="hljs-property">indent</span>;
      <span class="hljs-keyword">let</span> tagName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>;
      <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
      <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
      <span class="hljs-keyword">if</span> (root &amp;&amp; !rootIncorrect.<span class="hljs-title function_">includes</span>(tag)) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;=&#x27;: incorrect fragment tag in fragment, <span class="hljs-subst">${tag}</span>`</span>;
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
        <span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
        rootIncorrect.<span class="hljs-title function_">push</span>(tag);
      }
      <span class="hljs-keyword">if</span> (add &amp;&amp; !addIncorrect.<span class="hljs-title function_">includes</span>(tag)) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;+&#x27;: incorrect fragment tag in fragment: <span class="hljs-subst">${tag}</span>`</span>;
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
        <span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
        addIncorrect.<span class="hljs-title function_">push</span>(tag);
      }
      <span class="hljs-keyword">if</span> (!fragments.<span class="hljs-title function_">has</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>) &amp;&amp; tagName !== <span class="hljs-string">&quot;(?&lt;tagName&gt;.+)&quot;</span> &amp;&amp; !fragmentNotFound.<span class="hljs-title function_">includes</span>(tagName)) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Could not find fragment <span class="hljs-subst">${tag}</span> (<span class="hljs-subst">${tagName}</span>)`</span>;
        <span class="hljs-keyword">let</span> range = <span class="hljs-title function_">fragmentUsageRange</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], tagName);
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg, range);
        <span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
        fragmentNotFound.<span class="hljs-title function_">push</span>(tagName);
      }
      <span class="hljs-keyword">let</span> fragmentToReplaceWith = fragments.<span class="hljs-title function_">get</span>(tagName) || <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">if</span> (fragmentToReplaceWith) {
        <span class="hljs-keyword">let</span> code = fragmentToReplaceWith.<span class="hljs-property">code</span>;
        <span class="hljs-keyword">let</span> lines = code.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">let</span> indentedLines = lines.<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e, _</span>) {
          <span class="hljs-keyword">return</span> indent + e;

        });
        <span class="hljs-keyword">let</span> newcode = indentedLines.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
        fragmentReplaced = <span class="hljs-literal">true</span>;
        fragmentInfo.<span class="hljs-property">code</span> = fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">replace</span>(tag, newcode);
        fragments.<span class="hljs-title function_">set</span>(fragmentName, fragmentInfo);
      }
    }
  }
  <span class="hljs-keyword">if</span>(!fragmentReplaced) {
    <span class="hljs-keyword">break</span>;
  }
}
<span class="hljs-keyword">while</span> (pass &lt; <span class="hljs-number">25</span>);
</code></pre>

</div>
</div><h2>custom code fence rendering</h2>
<p>Our extension uses a custom code fence rendering rule to ensure the code
fragment name is also rendered as part of the fence.</p>
<p>Essentially the old, default rendering rule for fences is first used to create
the original fence.</p>
<p>Then the <code>token.info</code> is matched against the <code>FRAGMENT_RE</code> regular expression.
If we have a match we prepare the <code>HTML</code> code to essentially wrap around the
<code>HTML</code> as generated by the default rule.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;renderCodeFence rule&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderCodeFence</span>(<span class="hljs-params">tokens : Token[],
             idx : <span class="hljs-built_in">number</span>,
             options : MarkdownIt.Options,
             env : <span class="hljs-built_in">any</span>,
             slf : Renderer</span>) {
  <span class="hljs-keyword">let</span> rendered = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">if</span> (oldFence) {
    rendered = <span class="hljs-title function_">oldFence</span>(tokens, idx, options, env, slf);

    <span class="hljs-keyword">let</span> token = tokens[idx];
    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">info</span>) {
      <span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
      <span class="hljs-keyword">if</span> (match &amp;&amp; match.<span class="hljs-property">groups</span>) {
        <span class="hljs-keyword">let</span> lang = match.<span class="hljs-property">groups</span>.<span class="hljs-property">lang</span>.<span class="hljs-title function_">trim</span>();
        <span class="hljs-keyword">let</span> name = match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>;
        <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
        <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
        <span class="hljs-keyword">let</span> fileName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">fileName</span>;
        <span class="hljs-keyword">if</span> (name) {
          root = root || <span class="hljs-string">&#x27;&#x27;</span>;
          add = add || <span class="hljs-string">&#x27;&#x27;</span>;
          rendered =
<span class="hljs-string">`&lt;div class=&quot;codefragment&quot;&gt;
&lt;div class=&quot;fragmentname&quot;&gt;&amp;lt;&amp;lt;<span class="hljs-subst">${name}</span>&amp;gt;&amp;gt;<span class="hljs-subst">${root}</span><span class="hljs-subst">${add}</span>&lt;/div&gt;
&lt;div class=&quot;code&quot;&gt;
<span class="hljs-subst">${rendered}</span>
&lt;/div&gt;
&lt;/div&gt;`</span>;
        }
      }
    }
  }

  <span class="hljs-keyword">return</span> rendered;
};
</code></pre>

</div>
</div><h2>Register the literate.process command</h2>
<p>The command <code>literate.process</code> is registered with Visual Studio Code. The
disposable that gets returned by <code>registerCommand</code> is held in
<code>literateProcessDisposable</code> so that we can push it into <code>context.subscriptions</code>.</p>
<p>Here we find the main program of our <code>literate.process</code> command. Our
<em>MarkdownIt</em> is set up, <code>.literate</code> files are searched and iterated. Each
<code>.literate</code> file is rendered, and code fragments are harvested. Finally code
fragments are extrapolated and saved to their respective source code files. The
<code>HTML</code> files are also saved to files.</p>
<p>Diagnostic messages are also handled here. Errors and warnings are shown where
necessary. On successfull completion a simple status bar message will be used.
An information diagnostic message is not good here, because that will prevent
the usage of <code>literate.process</code> in for instance <code>tasks.json</code>, since the
diagnostic message will block execution of a task if it were used as prelaunch
task. That is obviously not good for the workflow.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;register literate.process&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">let</span> literateProcessDisposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(
  <span class="hljs-string">&#x27;literate.process&#x27;</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    theOneRepository.<span class="hljs-title function_">processLiterateFiles</span>(<span class="hljs-literal">undefined</span>);
    <span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">setStatusBarMessage</span>(<span class="hljs-string">&quot;Literate Process completed&quot;</span>, <span class="hljs-number">5000</span>);
});

context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(literateProcessDisposable);
</code></pre>

</div>
</div><h2>Register the literate.create_fragment_for_tag command</h2>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;register literate.create_fragment_for_tag&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">let</span> literateCreateFragmentForTagDisposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(
  <span class="hljs-string">&#x27;literate.create_fragment_for_tag&#x27;</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">range? : vscode.Range</span>) {
    <span class="hljs-title function_">createFragmentForTag</span>(range);
  }
);

context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(literateCreateFragmentForTagDisposable);
</code></pre>

</div>
</div><h3>literate.create_fragment_for_tag implementation</h3>
<p>The <code>literate.create_fragment_for_tag</code> will do as its name suggests. When the
position in the document is on a tag then the command will add a code fence to
the document.</p>
<p>If the tag at the position is fragment usage in a fragment then the code fence
will be created after the current fragment using the same language as specified
in the current fragment. If the tag is a fragment mention then instead the
current fragment map is checked for what the most used language is and that is
pre-filled.</p>
<p>First we ensure we have an active editor.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createFragmentForTag</span>(<span class="hljs-params">range? : vscode.Range</span>)
{
  <span class="hljs-keyword">let</span> activeEditor = vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>;
  <span class="hljs-keyword">if</span>(activeEditor)
  {
</code></pre>

</div>
</div><p>From the active editor we find the document. The editor also has the information
about where our cursor currently is, under <code>active</code> property on <code>selection</code>, but
we use <code>range.start</code> if <code>range</code> was passed in.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">document</span> = activeEditor.<span class="hljs-property">document</span>;
    <span class="hljs-keyword">const</span> position = range ? range.<span class="hljs-property">start</span> : activeEditor.<span class="hljs-property">selection</span>.<span class="hljs-property">active</span>;
</code></pre>

</div>
</div><p>For the document and position we determined we can get the fragment at that
location. We retrieve that from the repository so that we can get the range for
the fragment use.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">const</span> fragmentLocation = theOneRepository.<span class="hljs-title function_">getFragmentTagLocation</span>(
      <span class="hljs-variable language_">document</span>,
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">lineAt</span>(position),
      position);
</code></pre>

</div>
</div><p>With the range of the fragment use in hand we can find the <strong>Markdown</strong> token
where this range is contained for the document we're in.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">const</span> tokenUsage = theOneRepository.<span class="hljs-title function_">getTokenAtPosition</span>(
      <span class="hljs-variable language_">document</span>,
      fragmentLocation.<span class="hljs-property">range</span>);
</code></pre>

</div>
</div><p>The token needs to be valid to be able to use it for determining the insert. The
<code>map</code> property on <code>Token</code> will tell us the begin and end lines. We want to add
our new fragment definition after this token. We'll access the <code>map</code> when we are
ready to do an <code>insert</code> on the <code>WorkspaceEdit</code>.</p>
<p>We initialize a temporary language id to <code>LANGID</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">if</span>(tokenUsage.<span class="hljs-property">token</span> &amp;&amp; tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">map</span>)
    {
      <span class="hljs-keyword">let</span> workspaceEdit = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">WorkspaceEdit</span>();
      <span class="hljs-keyword">let</span> langId : <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;LANGID&#x27;</span>;
</code></pre>

</div>
</div><p>If we have a <code>fence</code> <code>Token</code> we try matching the <code>info</code> property of the token
with <code>FRAGMENT_RE</code>. This gives us the language id used for that fence. We'll be
using the same language id for the new code fragment.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>      <span class="hljs-keyword">if</span>(tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span> &amp;&amp; tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">map</span>)
      {
        <span class="hljs-keyword">let</span> match = tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
        <span class="hljs-keyword">if</span>(match &amp;&amp; match.<span class="hljs-property">groups</span>) {
          langId = match.<span class="hljs-property">groups</span>.<span class="hljs-property">lang</span>;
        }
      }
</code></pre>

</div>
</div><p>We can now create the new fragment string with the language id and the fragment
tag name we want to create the fragment for.</p>
<p>Newlines at the begin and end of the string ensure the fragment won't be created
without the necessary empty lines.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>      <span class="hljs-keyword">let</span> newFragment = <span class="hljs-string">`\n<span class="hljs-subst">${FENCE}</span> <span class="hljs-subst">${langId}</span> : <span class="hljs-subst">${OPENING}</span><span class="hljs-subst">${fragmentLocation.name}</span><span class="hljs-subst">${CLOSING}</span>=\n<span class="hljs-subst">${FENCE}</span>\n`</span>;
</code></pre>

</div>
</div><p>Now that we have the new fragment text ready we can call <code>insert</code> on our
workspace edit. The position is created with the second element of the
<code>token.map</code> as the line number, and 0 to have the insert happen at the beginning
of the line.</p>
<p>Finally we apply the workspace edit to our workspace. This will give us the new
fragment right after the paragraph or code fence with the fragment name we found
at the position we ran the command at.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;create fragment for tag&gt;&gt;=+</div>
<div class="code">
<pre><code>      workspaceEdit.<span class="hljs-title function_">insert</span>(
        <span class="hljs-variable language_">document</span>.<span class="hljs-property">uri</span>,
        <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>),
        newFragment
        );
      vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">applyEdit</span>(workspaceEdit);
    }
  }
}
</code></pre>

</div>
</div><h2>Register the literate.split_fragment command</h2>
<p>Registering the <code>literate.split_fragment</code> command, setting it up so that it
could take a <code>vscode.Position</code> parameter, which helps in programmatically firing
the command for a certain pre-computed location.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;register literate.split_fragment&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">let</span> literateSplitFragmentDisposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(
  <span class="hljs-string">&#x27;literate.split_fragment&#x27;</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">position? : vscode.Position</span>) {
    <span class="hljs-title function_">splitFragment</span>(position);
  }
);

context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(literateSplitFragmentDisposable);
</code></pre>

</div>
</div><h3>literate.split_fragment implementation</h3>
<p>The <code>literate.split_fragment</code> will split the current fragment below the line
where the cursor is. If no active text editor was found nothing will happen.
With one in hand though we can either use the position given to the method, or
otherwise use the cursor location in the document.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;split fragment&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">splitFragment</span>(<span class="hljs-params">position_? : vscode.Position</span>)
{
  <span class="hljs-keyword">let</span> activeEditor = vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>;
  <span class="hljs-keyword">if</span>(activeEditor)
  {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">document</span> = activeEditor.<span class="hljs-property">document</span>;
    <span class="hljs-keyword">const</span> position = position_ ? position_ : activeEditor.<span class="hljs-property">selection</span>.<span class="hljs-property">active</span>;
</code></pre>

</div>
</div><p>With the document and position we can find the <code>Token</code> at that location.
Continue only if it is a fence.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;split fragment&gt;&gt;=+</div>
<div class="code">
<pre><code>    <span class="hljs-keyword">const</span> tokenUsage = theOneRepository.<span class="hljs-title function_">getTokenAtPosition</span>(
      <span class="hljs-variable language_">document</span>,
      <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(position, position));
    <span class="hljs-keyword">if</span>(tokenUsage.<span class="hljs-property">token</span> &amp;&amp; tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span>)
    {
</code></pre>

</div>
</div><p>Next we match the info line, we want to ensure we have actually a fragment here.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;split fragment&gt;&gt;=+</div>
<div class="code">
<pre><code>      <span class="hljs-keyword">let</span> match = tokenUsage.<span class="hljs-property">token</span>.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
      <span class="hljs-keyword">if</span>(match &amp;&amp; match.<span class="hljs-property">groups</span>)
      {
</code></pre>

</div>
</div><p>From the matched info line we take the language identifier and the fragment tag
name. We can create the text that will split the current fragment.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;split fragment&gt;&gt;=+</div>
<div class="code">
<pre><code>        <span class="hljs-keyword">let</span> langId = match.<span class="hljs-property">groups</span>.<span class="hljs-property">lang</span>;
        <span class="hljs-keyword">let</span> textToInsert = <span class="hljs-string">`<span class="hljs-subst">${FENCE}</span>\n\n<span class="hljs-subst">${FENCE}</span> <span class="hljs-subst">${langId}</span> : <span class="hljs-subst">${OPENING}</span><span class="hljs-subst">${match.groups.tagName}</span><span class="hljs-subst">${CLOSING}</span>=+\n`</span>;
</code></pre>

</div>
</div><p>Finally we can create the workspace edit, make the insert on the next line from
the cursor, and apply the edit.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;split fragment&gt;&gt;=+</div>
<div class="code">
<pre><code>        <span class="hljs-keyword">let</span> workspaceEdit = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">WorkspaceEdit</span>();
        workspaceEdit.<span class="hljs-title function_">insert</span>(
          <span class="hljs-variable language_">document</span>.<span class="hljs-property">uri</span>,
          <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(position.<span class="hljs-property">line</span>+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),
          textToInsert
          );
        vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">applyEdit</span>(workspaceEdit);
      }
    }
  }
}
</code></pre>

</div>
</div><h2>Diagnostics</h2>
<p>In this chapter are a few methods that help creating and updating diagnostics.
These diagnostics help the literate programmer determining if there are
problems with the text and where.</p>
<h3>Updating diagnostics</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;diagnostic updating&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDiagnostics</span>(<span class="hljs-params">
  uri: vscode.Uri,
  collection: vscode.DiagnosticCollection,
  diagnostic : vscode.Diagnostic | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">if</span> (uri) {
    <span class="hljs-keyword">if</span> (diagnostic) {
      <span class="hljs-keyword">const</span> diags = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(collection.<span class="hljs-title function_">get</span>(uri) || []);
      diags.<span class="hljs-title function_">push</span>(diagnostic);
      collection.<span class="hljs-title function_">set</span>(uri, diags);
    }
  } <span class="hljs-keyword">else</span> {
    collection.<span class="hljs-title function_">clear</span>();
  }
}
</code></pre>

</div>
</div><h3>Creating an error diagnostic</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;diagnostic updating&gt;&gt;=+</div>
<div class="code">
<pre><code>
<span class="hljs-comment">/**
 * Create diagnostic for a given token with message.
 * <span class="hljs-doctag">@param</span> token Token that carries the faulty code fragment
 * <span class="hljs-doctag">@param</span> message Error message
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createErrorDiagnostic</span>(<span class="hljs-params">token: Token, message: <span class="hljs-built_in">string</span>, range? : vscode.Range</span>) : vscode.<span class="hljs-property">Diagnostic</span> {
  range = range ? range : <span class="hljs-title function_">fragmentRange</span>(token);
  <span class="hljs-keyword">let</span> <span class="hljs-attr">diagnostic</span>: vscode.<span class="hljs-property">Diagnostic</span> = {
    <span class="hljs-attr">severity</span>: vscode.<span class="hljs-property">DiagnosticSeverity</span>.<span class="hljs-property">Error</span>,
    <span class="hljs-attr">message</span>: message,
    <span class="hljs-attr">range</span>: range
  };

  <span class="hljs-keyword">return</span> diagnostic;
}
</code></pre>

</div>
</div><h3>Line number of fragment start</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;diagnostic updating&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-comment">/**
 * Give the location of the line in the Markup document that contains the
 * tag declaration.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragment</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>]) : -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> linenumber;
}
</code></pre>

</div>
</div><h3>Line number of fragment end</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;diagnostic updating&gt;&gt;=+</div>
<div class="code">
<pre><code>
<span class="hljs-comment">/**
 * Give the location of the last line in the Markup document that contains the
 * code fragment.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragmentEnd</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>] ) : -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> linenumber;
}
</code></pre>

</div>
</div><h3>Range of whole fragment in text</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;diagnostic updating&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-comment">/**
 * Give range for the code fragment, including tag.
 * <span class="hljs-doctag">@param</span> token Token to create range for
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fragmentRange</span>(<span class="hljs-params">token: Token</span>): vscode.<span class="hljs-property">Range</span> {
  <span class="hljs-keyword">let</span> startTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>) + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">let</span> endTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>) - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragment</span>(token), startTagName);
  <span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragmentEnd</span>(token), endTagName);
  <span class="hljs-keyword">let</span> <span class="hljs-attr">range</span>: vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(start, end);
  <span class="hljs-keyword">return</span> range;
}
</code></pre>

</div>
</div><h3>Fragment usage range</h3>
<p>This method gives a <code>Range</code> for the given tag name based on the passed in
<code>Token</code>. The line number for the occurrance is computed, along with the begin
and and positions within the line.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;diagnostic updating&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fragmentUsageRange</span>(<span class="hljs-params">token : Token, tagName : <span class="hljs-built_in">string</span></span>) : vscode.<span class="hljs-property">Range</span>
{
  <span class="hljs-keyword">let</span> startLineNumber = <span class="hljs-title function_">locationOfFragment</span>(token);
  <span class="hljs-keyword">const</span> lines = token.<span class="hljs-property">content</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);
  <span class="hljs-keyword">let</span> index : <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines)
  {
    startLineNumber++;
    index = line.<span class="hljs-title function_">indexOf</span>(tagName);
    <span class="hljs-keyword">if</span>(index &gt; -<span class="hljs-number">1</span>)
    {
      <span class="hljs-keyword">break</span>;
    }
  }
  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(startLineNumber, index - <span class="hljs-number">2</span>);
  <span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(startLineNumber, index + tagName.<span class="hljs-property">length</span> + <span class="hljs-number">2</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(start, end);
}
</code></pre>

</div>
</div><h2>Utility functions</h2>
<h3>Retrieving literate file uri list</h3>
<p>Function to get all literate files in a given workspace. We need to ensure that
we give the uris in the correct order. The order will be defined by an
<code>index.literate</code> if it exists. Otherwise use the order in which they are found
by <code>findFiles</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;utility functions&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLiterateFileUris</span>(<span class="hljs-params">
  workspaceFolder : vscode.WorkspaceFolder
</span>) : <span class="hljs-title class_">Promise</span>&lt;vscode.<span class="hljs-property">Uri</span>[]&gt;
{
  <span class="hljs-keyword">const</span> literateFilesInWorkspace : vscode.<span class="hljs-property">RelativePattern</span> =
        <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">RelativePattern</span>(workspaceFolder, <span class="hljs-string">&#x27;**/*.literate&#x27;</span>);
  <span class="hljs-keyword">const</span> _foundLiterateFiles = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>
        .<span class="hljs-title function_">findFiles</span>(literateFilesInWorkspace)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file)));
  <span class="hljs-keyword">let</span> foundLiterateFiles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">Uri</span>&gt;();
  &lt;&lt;see <span class="hljs-keyword">if</span> an index.<span class="hljs-property">literate</span> exists&gt;&gt;
  &lt;&lt;search index <span class="hljs-keyword">for</span> html links&gt;&gt;
  &lt;&lt;sort uris based on html link order&gt;&gt;
  <span class="hljs-keyword">return</span> foundLiterateFiles;
}
</code></pre>

</div>
</div><p>TBD: create instead a markup that allows us to express the literate file order
in whichever file we want.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;see if an index.literate exists&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> index = _foundLiterateFiles.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">uri</span> =&gt;</span> uri.<span class="hljs-property">path</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;index.literate&#x27;</span>));
<span class="hljs-keyword">if</span>(!index)
{
  <span class="hljs-keyword">return</span> _foundLiterateFiles;
}
</code></pre>

</div>
</div><p>We now parse the index file to get the state with markdown tokens. We don't need
the rendered HTML of the index document, so we discard that.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;search index for html links&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> md = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
<span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getFileContent</span>(index);
<span class="hljs-keyword">const</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span> = { <span class="hljs-attr">literateFileName</span>: <span class="hljs-string">&#x27;index.literate&#x27;</span>, <span class="hljs-attr">literateUri</span>: index, <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, md, {}) };
<span class="hljs-keyword">const</span> _ = md.<span class="hljs-title function_">render</span>(text, env);
</code></pre>

</div>
</div><p>We create a new list of strings to which we will add the file uris in the order
is found in the parsed tokens. We do that by looking for <code>bullet_open_list</code> and
<code>bullet_close_list</code>. We assume that inside these lists there will be items that
contain links. Once we've encountered an <code>bullet_open_item</code> we start looking for
<code>list_item_open</code>. When the token is found we get the inline token that is two
tokens away from the <code>list_item_open</code> token. We make sure that it has child
tokens, and that the first child token has a valid <code>attrs</code> property. Here we
find the uri to the HTML version of a <strong>literate</strong> file.</p>
<p>TBD add support for ordered list.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;sort uris based on html link order&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">let</span> links = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-keyword">let</span> bulletListOpen = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> token <span class="hljs-keyword">of</span> env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>)
{
  <span class="hljs-keyword">if</span>(token.<span class="hljs-property">type</span>===<span class="hljs-string">&#x27;bullet_list_open&#x27;</span>)
  {
    bulletListOpen = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span>(token.<span class="hljs-property">type</span>===<span class="hljs-string">&#x27;bullet_list_close&#x27;</span>)
  {
    bulletListOpen = <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span>(bulletListOpen &amp;&amp; token.<span class="hljs-property">type</span>==<span class="hljs-string">&#x27;list_item_open&#x27;</span>)
  {
    <span class="hljs-keyword">let</span> inline = env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>[idx+<span class="hljs-number">2</span>];
    <span class="hljs-keyword">if</span>(inline.<span class="hljs-property">children</span> &amp;&amp; inline.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">attrs</span>)
    {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> currentUri = inline.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">attrs</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> path = currentUri.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;html&quot;</span>, <span class="hljs-string">&quot;literate&quot;</span>);
        <span class="hljs-keyword">const</span> foundUri = _foundLiterateFiles.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">uri</span> =&gt;</span> uri.<span class="hljs-property">path</span>.<span class="hljs-title function_">endsWith</span>(path));
        <span class="hljs-keyword">if</span>(foundUri)
        {
          foundLiterateFiles.<span class="hljs-title function_">push</span>(foundUri);
        }
      } <span class="hljs-keyword">catch</span>(_) {}
    }
  }
  idx++;
}
</code></pre>

</div>
</div><p>Finally ensure that the index file also exists in the list to return.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;sort uris based on html link order&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">const</span> finalCheck = foundLiterateFiles.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">uri</span> =&gt;</span> uri.<span class="hljs-property">path</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;index.literate&#x27;</span>));
<span class="hljs-keyword">if</span>(!finalCheck)
{
  foundLiterateFiles.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, index);
}
</code></pre>

</div>
</div><h3>Write out HTML</h3>
<p>Function to write out the given <code>rendered</code> content out to a file. The <code>rendered</code>
string will be set into a HTML body. The header will be configured so that the
style sheet is referenced.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;utility functions&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">writeOutHtml</span>
      (fname : <span class="hljs-built_in">string</span>,
       folderUri : vscode.<span class="hljs-property">Uri</span>,
       rendered : <span class="hljs-built_in">string</span>) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt;
{
  <span class="hljs-keyword">const</span> html =
<span class="hljs-string">`&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
  <span class="hljs-subst">${rendered}</span>
  &lt;/body&gt;
&lt;/html&gt;`</span>;
  <span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(html, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
  fname = fname.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.literate&quot;</span>, <span class="hljs-string">&quot;.html&quot;</span>);
  <span class="hljs-keyword">const</span> fileUri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">joinPath</span>(folderUri, fname);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded));
};
</code></pre>

</div>
</div><h3>Get file content for uri</h3>
<p>For each <strong>literate</strong> file in the workspace we'll get eventually the text
content, but we do have to check if any of the files are opened in an editor.
Especially for on-the-fly updating of the tree view, but also for fragment name
completion and similar functionality we need to get the text from the
<code>TextDocument</code> instead of the file on disk. If there is a <code>TextDocument</code> that
corresponds to the <strong>literate</strong> file we are currently handling we read the text
into <code>currentContent</code>, otherwise we set it to an empty string.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;utility functions&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileContent</span>(<span class="hljs-params">
  file : vscode.Uri
</span>) : <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;
{
  <span class="hljs-keyword">const</span> currentContent = (<span class="hljs-function">() =&gt;</span>
      {
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> textDocument <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">textDocuments</span>) {
              <span class="hljs-keyword">if</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">asRelativePath</span>(file) === vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">asRelativePath</span>(textDocument.<span class="hljs-property">uri</span>)) {
                  <span class="hljs-keyword">return</span> textDocument.<span class="hljs-title function_">getText</span>();
              }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
      }
  )();
</code></pre>

</div>
</div><p>If <code>currentContent</code> is an empty string we read the content from the file on
disk, and decode it into <code>text</code>. If on the other hand we do have
<code>currentContent</code>, we use that for our <code>text</code> instead. The <code>currentContent</code>
wil be more up-to-date than what we have on disk.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;utility functions&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-keyword">const</span> content = currentContent ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">readFile</span>(file);
  <span class="hljs-keyword">const</span> text = currentContent ? currentContent : <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">decode</span>(content);
  <span class="hljs-keyword">return</span> text;
}
</code></pre>

</div>
</div><h2>The extension</h2>
<p>Our Visual Studio Code entry file is the <code>extension.ts</code> file. While developing
the plug-in the JavaScript version created from this, in <code>out/extension.js</code> is
set as the entry point for the extension, in <code>package.json</code>. But when it is
prepared for release on the Visual Studio Code marketplace this needs to be
changed to the minified and bundled version that gets realized as <code>out/main.js</code>.
This ensures, together with a properly set up <code>.vscodeignore</code> that the published
package stays small in size. Without that the package is easily over 2MB in
size, but properly configured it is under 400KB.</p>
<p>The extension main entry lies in the activation of the extension, as given by
<code>&lt;&lt;activate the extension&gt;&gt;</code>, but before we get there we need to set up several
bits and pieces that are required for the proper functioning of the tools.</p>
<p>First of all we import all the functionality and modules we are going to need.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-comment">/* Literate Programming by Nathan &#x27;jesterKing&#x27; Letwory */</span>

&lt;&lt;<span class="hljs-keyword">import</span> necessary modules <span class="hljs-keyword">for</span> literate&gt;&gt;
</code></pre>

</div>
</div><p>After the imports we introduce the <code>oldFence</code> where we will keep a hold of the
fence rule from the default <em>MarkdownIt</em> parser. I was not entirely sure how to
best tackle it, so for now it is here.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">let</span> oldFence : <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">RenderRule</span> | <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FENCE</span> = <span class="hljs-string">&#x27;```&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OPENING</span> = <span class="hljs-string">&#x27;&lt;&lt;&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLOSING</span> = <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>;
</code></pre>

</div>
</div><p>With that out of the way we introduce the interfaces we use in the Literate
Programming extension.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code>&lt;&lt;introduce interfaces&gt;&gt;

</code></pre>

</div>
</div><p>Next we set up the fragment regular expressions and define everything needed to
implement the fragment explorer. This explorer will show up in the Explorer bar
when a literate project is open. We need a representation for a node in the tree
view, a data provider for the tree view and then the actual tree view explorer
itself.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code>&lt;&lt;fragment regular expressions&gt;&gt;

&lt;&lt;fragment node&gt;&gt;

&lt;&lt;fragment tree provider&gt;&gt;

&lt;&lt;fragment explorer&gt;&gt;

&lt;&lt;fragment hover provider&gt;&gt;
</code></pre>

</div>
</div><p>For our extension we need to override the code fence rule since we want to
augment the rendering of the code fences. Specifically we want to add the
fragment line prior to the code block. This is explained in the section on
<code>&lt;&lt;renderCodeFence rule&gt;&gt;</code>.</p>
<p>Also we have a way to create a <em>MarkdownIt</em> parser the way we need it. It is
explained in more detail in the section on <code>&lt;&lt;create markdownit parser&gt;&gt;</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code>&lt;&lt;renderCodeFence rule&gt;&gt;

&lt;&lt;create markdownit parser&gt;&gt;

</code></pre>

</div>
</div><p>The central mechanism of the <strong>Literate Programming</strong> extension, the tools it
provides, are expressed in <code>&lt;&lt;render and collect state&gt;&gt;</code>,
<code>&lt;&lt;handle fragments&gt;&gt;</code> and <code>&lt;&lt;write out source files&gt;&gt;</code>. These all ensure that
all <strong>literate</strong> files can be iterated, parsed, rendered. And that from the
parsed state all the code fragments can be collected and extrapolated into the
source file or source files as written in the <strong>literate</strong> program.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code>&lt;&lt;render and collect state&gt;&gt;
&lt;&lt;handle fragments&gt;&gt;
&lt;&lt;write out source files&gt;&gt;
&lt;&lt;fragment repository&gt;&gt;
&lt;&lt;rename provider <span class="hljs-keyword">class</span>&gt;&gt;
&lt;&lt;code action provider <span class="hljs-keyword">class</span>&gt;&gt;
&lt;&lt;definition provider <span class="hljs-keyword">class</span>&gt;&gt;
&lt;&lt;reference provider <span class="hljs-keyword">class</span>&gt;&gt;
</code></pre>

</div>
</div><p>Utility function to determine the workspace folder for a TextDocument</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-params"><span class="hljs-variable language_">document</span> : vscode.TextDocument</span>) : vscode.<span class="hljs-property">WorkspaceFolder</span> | <span class="hljs-literal">undefined</span>
{
  <span class="hljs-keyword">if</span>(!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> || vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>)
  {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ws <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>)
  {
    <span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(ws.<span class="hljs-property">uri</span>.<span class="hljs-title function_">toString</span>(), <span class="hljs-variable language_">document</span>.<span class="hljs-property">uri</span>.<span class="hljs-title function_">toString</span>());
    <span class="hljs-keyword">if</span>(!relativePath.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;..&#x27;</span>))
    {
      <span class="hljs-keyword">return</span> ws;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}
</code></pre>

</div>
</div><p>Although the fragments mentioned above are the soul of the extension they are
not of much use without the proper activation. With this <code>activate</code>
implementation all providers and commands are registered with Visual Studio
Code.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code>&lt;&lt;activate the extension&gt;&gt;
</code></pre>

</div>
</div><div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code>&lt;&lt;diagnostic updating&gt;&gt;
&lt;&lt;utility functions&gt;&gt;
&lt;&lt;create fragment <span class="hljs-keyword">for</span> tag&gt;&gt;
&lt;&lt;split fragment&gt;&gt;
</code></pre>

</div>
</div><div class="codefragment">
<div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=+</div>
<div class="code">
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deactivate</span>(<span class="hljs-params"></span>) {}
</code></pre>

</div>
</div><h3>The imports</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;import necessary modules for literate&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">import</span> { <span class="hljs-title class_">TextDecoder</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;util&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> vscode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vscode&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">StateCore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/rules_core/state_core&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Token</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/token&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;markdown-it&quot;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Renderer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/renderer&#x27;</span>);

<span class="hljs-comment">// `import` here fails so instead we require the highlight module</span>
<span class="hljs-comment">// this way. Not sure why import fails. It would be great to find</span>
<span class="hljs-comment">// out the reason.</span>
<span class="hljs-keyword">const</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;highlight.js&#x27;</span>);

<span class="hljs-keyword">import</span> { grabberPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./grabber&#x27;</span>;
</code></pre>

</div>
</div><h3>Interfaces used in Literate Programming</h3>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;introduce interfaces&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WriteRenderCallback</span> {
  (
    fname : <span class="hljs-built_in">string</span>,
    folderUri : vscode.<span class="hljs-property">Uri</span>,
    content : <span class="hljs-built_in">string</span>
  ) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt;
};
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">WriteSourceCallback</span> {
  (
    workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>,
    fragments : <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;
  ) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt;
};

&lt;&lt;grabbed state <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;fragment information <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;token usage <span class="hljs-keyword">interface</span>&gt;&gt;
</code></pre>

</div>
</div><h3>Extension activation</h3>
<p>The extension activation sets up all our tools and data structures. The
activation happens through the <code>activate</code> function. This takes a context to
which we push all our disposables for proper cleanup when our extension gets
decativate. Note that our <code>activate</code> implementation is also marked <code>async</code>,
because we want to <code>await</code> where necessary.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;activate the extension&gt;&gt;=</div>
<div class="code">
<pre><code><span class="hljs-keyword">let</span> theOneRepository : <span class="hljs-title class_">FragmentRepository</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>) {
</code></pre>

</div>
</div><p>We start the activation by setting up the <code>FragmentRepository</code>. This is the hard
of the processing of literate projects. We give it the <code>context</code> so that it can
also push disposables to the <code>context.subscriptions</code> for proper cleanup.</p>
<p>With the repository set up we will process the entire workspace for literate
projects. We want to <code>await</code> here to ensure everything is ready, that is our
repository can provide fragments when requested.</p>
<p>With that done we place our repository in the <code>context.subscriptions</code>.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;activate the extension&gt;&gt;=+</div>
<div class="code">
<pre><code>  theOneRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentRepository</span>(context);
  <span class="hljs-keyword">await</span> theOneRepository.<span class="hljs-title function_">processLiterateFiles</span>(<span class="hljs-literal">undefined</span>);
  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(theOneRepository);
</code></pre>

</div>
</div><p>Now that the repository is up and running we can register all our commands,
views and providers. Note that we currently use <code>markdown</code> to register to. In
the future we would probably want to ensure that <code>.literate</code> becomes its own
language ID to register agains.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;activate the extension&gt;&gt;=+</div>
<div class="code">
<pre><code>  &lt;&lt;register literate.<span class="hljs-property">process</span>&gt;&gt;
  &lt;&lt;register literate.<span class="hljs-property">create_fragment_for_tag</span>&gt;&gt;
  &lt;&lt;register literate.<span class="hljs-property">split_fragment</span>&gt;&gt;
  &lt;&lt;register fragment tree view&gt;&gt;
  &lt;&lt;register completion item provider&gt;&gt;
  &lt;&lt;register definiton provider&gt;&gt;
  &lt;&lt;register reference provider&gt;&gt;

  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
    vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">registerHoverProvider</span>(<span class="hljs-string">&#x27;markdown&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentHoverProvider</span>(theOneRepository))
  );

  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
    vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">registerRenameProvider</span>(<span class="hljs-string">&#x27;markdown&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LiterateRenameProvider</span>(theOneRepository))
  );

  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
    vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">registerCodeActionsProvider</span>(<span class="hljs-string">&#x27;markdown&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LiterateCodeActionProvider</span>(theOneRepository))
  );
</code></pre>

</div>
</div><p>From our extension activation we return an extension of the built-in
<em>MarkdownIt</em> parser. This way we get a preview where the parser is configured
the same way as our extension. This should result in previews that are close to
what our HTML rendering does.</p>
<div class="codefragment">
<div class="fragmentname">&lt;&lt;activate the extension&gt;&gt;=+</div>
<div class="code">
<pre><code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ready to do some Literate Programming&#x27;</span>);

  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">extendMarkdownIt</span>(<span class="hljs-params">md: <span class="hljs-built_in">any</span></span>) {
      md.<span class="hljs-title function_">use</span>(grabberPlugin);
      oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
      md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
      <span class="hljs-keyword">return</span> md;
    }
  };
};
</code></pre>

</div>
</div><h2>Afterword</h2>
<p>So you have made it this far - or perhaps you just skipped over a lot of text.
If you actually read all the text up to this point you have read also all of the
code for the entire <strong>Literate Programming</strong>. I appreciate you took the time to
read this document. I hope it helped you get more interested in the <strong>literate
programming</strong> paradigm.</p>
<p>I invite you to install the <strong>Literate Programming</strong> extension for Visual Studio
Code and start using it in your daily work.</p>

  </body>
</html>